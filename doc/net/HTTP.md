HTTP 基础
=========================

> 记录日常工作中的一些问题
>
> https://www.jianshu.com/p/8565912949bb

##TCP / IP 协议组

TCP / IP 是一个协议组，一共分为四层：链路层，网络层，传输层和应用层。

- 链路层：负责在以太网，WiFi 的底层网络上发送原始数据包，使用 MAC 地址来标记设备。

- 网络层：根据 IP 协议，在这一层上会用 IP 地址取代了 MAC 地址，组成了虚拟网络（广域网，局域网），这一层还包含了  ICMP 协议， ARP 协议，RARP 协议。
- 传输层：这一层的协议的指责是保证数据在两个 IP 间可靠的传输。是 TCP 协议和 UDP 协议工作的层次。
- 应用层：这一层主要都是面向具体应用的协议，包含 FTP，HTTP，TELNET，SMTP，DNS 等

还有一种网络分层模型是：OSI 网络分层，也就是传统的 **七层模型**，而 TCP/IP 是 **四层模型**。

### TCP 协议

TCP 协议提供的是面向连接，可靠的字节流服务。

- 在交换数据之前，通过三次握手建立连接。
- 交换的数据是顺序的，且不会重复的，可以进行大数据传输。
- 不限制数据的大小，TCP 数据包是分包传输的，一个包的大小为 1522 字节（head 共 22 字节，payload 为1500 字节）

TCP 的三次握手：

- 第一次握手：客户端发送 syn 包(syn=j)，并进入 SYN_SEND 状态，等待服务器确认。
- 第二次握手：服务端收到客户端的 syn 包，确认客户端的 SYN 包(syn=j+1)，同时自己也发送一个 syn 包 （syn=k，SYN+ACK 包），服务器进入 SYN_RECV 状态。
- 第三次握手：客户端收到服务端的 syn 包，向服务器发送确认包（ack=k+1，ACK包）发送完毕，客户端和服务器进入ESTABLISHED 状态。完成三次握手。

TCP 的数据交换也需要用到 ACK 确认，客户端每收到两个 TCP 数据包，就会发送一条确认消息（ACK），包含：

- 期待下个数据包的编号（确保有序性和包的完整性，防止服务端发送后丢包）
- 接收窗口的剩余容量（确保服务端发送的速率不会超过上限，TCP 慢启动机制）

### UDP 协议

UDP协议提供的是一个无连接协议，每一个数据报都是独立的信息，包含完整的源地址和目的地址。因此是否能到达目的地，以及到达目的地的时间以及内容的正确性无法保证。

- 通信之前不需要连接，所以可以实现广播发送。
- 传输的数据有大小限制，数据报必须限定在 64 KB 以内。
- 无法保证数据的先后顺序。
- 通常用于多点通信和实时的数据业务。

## HTTP/1.x

HTTP 协议是建立在 TCP 协议之上的一种应用，连接使用的是 **请求-响应** 的方式。不仅在请求时需要建立 TCP 连接，还需要客户端在向服务器发出请求后，请求中要包含`请求方法`，`URI`，`协议版本`以及`其他相关的 MIME 样式`的消，服务端才能回复数据。在请求结束后就会主动释放连接没，因此 HTTP 是一种短连接。

> 需要注意的是 HTTP/1.0 为每一次的 HTTP 请求/响应建立一条新的 TCP 链接，因此一个包含 HTML 内容和图片的页面将需要建立多次的短期的 TCP 链接，并且每个 TCP 链接的建立都需要 3 次握手。（HTTP/1.1 后提出可持续链接（keeplive），HTTP/2.0 后提出多路复用都可以重复使用传输消息，减少链接建立次数和开销）

## HTTP/2

HTTP/2 相比 HTTP/1 大幅度提升了网页的性能，其中主要包含了以下几种特性：

### 多路复用

在理解 HTTP/2 的多路复用之前需要先理解两个概念 **帧（frame）** 和 **流（stream）**

#### 帧（frame）

这是 HTTP/2 中数据传输的最小单位，因此帧中需要表达 HTTP/1.x 中的各个部分，以及对其进行优化。每一帧都包含了几个字端，例如 length，type，stream identifier，frame payload 等，其中 type 表示帧类型。

#### 流 （stream）

这是 HTTP/2 中逻辑上的概念，在一个 TCP 连接上，我们可以不断向对方发送消息，每一个消息都可是一帧，而每一帧中的 stream identifier 字端表明这一帧属于哪个“流”。在对方接收时候，根据 stream identifier 拼接每个流的所有帧组成一整块数据。把 HTTP/1.x 的每个请求都当作一个“流”，那么将请求变成多个流，响应数据切成多个帧，不同流中的帧交错的发送给客户端，这就是 HTTP/2 中的多路复用。

- 服务端可以同时收到不同的请求，然后同时响应这些请求，然后将响应数据切成不同的帧并发出去。
- 流的ID都是奇数表示由客户端发起，如果是偶数则表示由服务端发起。

多路复用让 HTTP 的连接变得更加的廉价，解决了关键请求被阻塞的问题。

### 头信息压缩

// 待更新

### 服务器推送

这个服务器推送必须遵循请求-响应这个模型，客户端在交换 SETTINGS 帧时，需要设置 SETTING_ENABLE_PUSH(0x2) = 1，显式允许服务器推送，才可以进行推送。

### 避免重定向

通过在响应头部加上 `Strict-Transport-Security: max-age=31536000` 告诉浏览器，必须用 HTTPS 访问，让浏览器帮忙做转换，而不需要经过服务器才知道转换。

## Cookie 

HTTP 协议是无状态的，所以就需要使用 Cookies 了，服务器通过设置和读取 Cookies 中包含的信息，维护用户跟服务器会话的状态。

- Cookie 是由服务器生产的，并保存在客户端的。
- 服务器为用户生成一个唯一的识别码 Cookie Id，创建一个 Cookie 对象，并设置一个过期时间。
- 用户请求服务器时，会将 Cookie 放入到 HTTP 响应报头（Set-Cookie）中。
- 服务器接受到用户的 HTTP 请求，从报头中取出 Cookie，找到需要的东西。
- Cookie 会增加 HTTP 流量，并且是明文传递的，有安全隐患，可以被劫持篡改，建议进行加密。
- Cookie 的大小限制在 4KB 左右。

和 Session 的区别：Session是保存在服务器上的，每个用户都会产生一个Session，如果并发用户多，容易耗费大量内存，但安全性更好。最后就是 Cookie 支持跨域，而 Session 不支持跨域。