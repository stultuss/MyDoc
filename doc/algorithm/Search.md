搜索算法
=========================

> 记录面试中的一些问题
>

## 回溯

回溯法是一种选优搜索的过程，又叫做试探法，是一种根据条件不断向前试探，当条件不满足则回退到起点再试探吓一条路，直到找到解的过程。它的思想是贪心法类似，**但贪心求出的解一定是近似最优解，而回溯法得出的解一定是最优解，因为当不满足条件时候，会倒退到最初位置并排出掉上一个选择的路径**。比较经典的算法是：深度优先算法（DFS），比较出名的问题有：八皇后问题。解题步骤如下：

- 针对问题，确定问题的解空间，并且解空间应该至少包含问题的一个（最优）解。
- 确定节点的扩展搜索规则。
- 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

> 理解：回溯法可以解决的问题可以抽象成一个树，我们的目标是：
>
> 1. 有没有 good leaf（有没有解）
> 2. 有多少 good leaf（求所有解的个数）
> 3.  good leaf 在哪里（求所有解的信息）
> 4. 哪个 good leaf 最好（求最优解）

### 习题：八皇后问题

> 在**8**×**8**格的国际象棋上摆放**八**个**皇后**，使其不能互相攻击，即任意两个**皇后**都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

```javascript
function NQueen(pos, n) {
  // 满足数量，打印
  if (n === pos.length) {
    console.log(pos);
    return;
  }
  
  // 遍历每一列，为 post[n] 查找可摆放的列(i)
  for (let i = 0; i < 8; i++) {
    // 尝试将 post[n] 摆放到 i 的位置
    pos[n] = i;
  
    // 开始确定 0 ～ n 列，n 表示已经确定皇后位置的列数（j < n, j++ 就是往回回溯已经确定位置的）
    let j = 0;
    while (j < n || n === 0) {
      // 当只确定第1个皇后的位置，开始遍历查找下一个皇后可摆放的位置。
      if (n === 0) {
        NQueen(pos, n + 1);
        break;
      }
      // 已确定皇后的列（post[j]）和当前列（i）相等（重合），判定同列失败退出
      if (pos[j] === i) {
        break;
      }
      // 已确定皇后的列 (post[j]) 与当前列（i）相差为 1 的情况下列数相减不可为 1（n - j），判定为斜角失败
      if (Math.abs(pos[j] - i) === n - j) {
        break
      }
      // 正常通过遍历，继续查找下一个皇后可摆放的位置。
      if (j === n - 1) {
        NQueen(pos, n + 1);
      }
      
      j++;
    }
  }
}

NQueen([1, 1, 1, 1, 1, 1, 1, 1], 0);
```

## 递归

递归法是程序员常用的算法，很多经典的排序，计算以及遍历都用到了递归。

主要的特点：

1. 递归就是方法理调用自身。
2. 在递增归策略中，必须有一个明确的结束条件。
3. 递归算法都很简洁，但运行效率低，一般不提倡用递归设计程序。
4. 递归调用的过程中，系统为每一层的返回点，局部变量开辟栈来存储，容易造成栈溢出。

经典算法：计算斐波那契数列 (公式：f(n) = f(n-1) + f(n-2))

```javascript
function fib(n) {
  if (n < 2) return n;
  return fib(n - 1) + fib(n - 2);
}
```

## 剪枝（算法优化）

剪枝法又称为剪枝策略，属于算法优化范畴，通常应用在 DFS 和 BFS 搜索算法中。简单一句话解释：**寻找过滤条件，提前减少不必要的搜索路径。**

拿背包问题来解释：

1. 当一件物品的重量或尺寸很大，背包放不下，条件不合法。这属于可行性剪枝。
2. 判断价值密度或价值尺寸小于所有物品的平均值，不属于最优解，这属于最优性剪枝。
3. 已经判断过一件物品并记录下重量尺寸价值和结果，再次遇到类似物品直接返回结果，这属于记忆化搜索。
4. 迷宫类题目，每到一个节点都将八个方向进行排序，离终点最近的方向排最前面，这属于搜索顺序剪枝。