搜索算法
=========================

## 回溯

回溯法是一种选优搜索的过程，又叫做试探法，是一种根据条件不断向前试探，当条件不满足则回退到起点再试探吓一条路，直到找到解的过程。它的思想是贪心法类似，**但贪心求出的解一定是近似最优解，而回溯法得出的解一定是最优解，因为当不满足条件时候，会倒退到最初位置并排出掉上一个选择的路径**。比较经典的算法是：深度优先算法（DFS），比较出名的问题有：八皇后问题。解题步骤如下：

- 针对问题，确定问题的解空间，并且解空间应该至少包含问题的一个（最优）解。
- 确定节点的扩展搜索规则。
- 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

> 理解：回溯法可以解决的问题可以抽象成一个树，我们的目标是：
>
> 1. 有没有 good leaf（有没有解）
> 2. 有多少 good leaf（求所有解的个数）
> 3.  good leaf 在哪里（求所有解的信息）
> 4. 哪个 good leaf 最好（求最优解）

## 递归

递归法是程序员常用的算法，很多经典的排序，计算以及遍历都用到了递归。

主要的特点：

1. 递归就是方法理调用自身。
2. 在递增归策略中，必须有一个明确的结束条件。
3. 递归算法都很简洁，但运行效率低，一般不提倡用递归设计程序。
4. 递归调用的过程中，系统为每一层的返回点，局部变量开辟栈来存储，容易造成栈溢出。

经典算法：计算斐波那契数列 (公式：f(n) = f(n-1) + f(n-2))

```javascript
function fib(n) {
  if (n < 2) return n;
  return fib(n - 1) + fib(n - 2);
}
```

## 剪枝（算法优化）

剪枝法又称为剪枝策略，属于算法优化范畴，通常应用在 DFS 和 BFS 搜索算法中。简单一句话解释：**寻找过滤条件，提前减少不必要的搜索路径。**

拿背包问题来解释：

1. 当一件物品的重量或尺寸很大，背包放不下，条件不合法。这属于可行性剪枝。
2. 判断价值密度或价值尺寸小于所有物品的平均值，不属于最优解，这属于最优性剪枝。
3. 已经判断过一件物品并记录下重量尺寸价值和结果，再次遇到类似物品直接返回结果，这属于记忆化搜索。
4. 迷宫类题目，每到一个节点都将八个方向进行排序，离终点最近的方向排最前面，这属于搜索顺序剪枝。