Memcache
=========================

> 记录日常工作中的一些问题

## 介绍

Memcache 是一个高性能的分布式 key-value 缓存系统。与 Redis 不同的是，它仅支持二进制和String格式的数据。由于数据是存放在服务器的内存空间中的，所以访问速度比数据库的磁盘IO会更快一点，提高了服务的响应速度（同样的，如果服务重启或崩溃会导致系统中存储的数据全部消失）。

## 对比

Memcache 和 Redis 的性能都足够的高，可以不必关心性能问题。但还是需要了解其优缺点：

1. Redis 只能使用单核，但其 QPS 能达到 100K /s，而 Memcache 可以使用多核，并且由于只支持字符串，所以其读写 QPS 比 Redis 更快。
2. Redis 发生 OOM 并不会直接导致崩溃，而 Memcache 发生 OOM 必定直接崩溃，导致全部数据丢失。
3. Redis 可以将数据持久化到硬盘上。
4. Redis 可以使用系统集群，Memcache 的集群依赖开发者自己写的缓存分片算法，例如：一致性哈希算法。

**总结：**

- 如果工作场景只需要一个简单的 key-value 缓存系统的话，Memcache 就可以满足你的要求，并且比 Reids 拥有更好的读写性能。 

- 如果工作场景需要将缓存数据持久化或者结构化的时候，你可以选择 Redis。

## 内存分配

Memcache 的内存分配有几个关键的概念：

- Page：默认情况下，一个 Page 是 1M，当需要申请内存时， Memcache 会划分出一个新的 Page 并分给 Slab，一旦 Page 被分配就不会被回收或重新分配。

- Slab：Memcache 在启动时候，会预先将数据空间划分成不同容量大小的 Slabs，每个 Slabs 会负责一定大小范围内的数据存储。默认情况下，下一个 slab 的最大值会是前一个的 1.25 倍，可以通过配置修改。举例：

  Slab 1 范围是 0～104 bytes，那 Slab 2 的范围是将会是 104 ～ 136 bytes

- Chunk：这是真正存放缓存数据的单位，它的大小等于管理它的 Slab 的最大存放大小。

### 内存浪费

根据 Page/Slab/Chunk 的概念，理解了这三者的关系。可以很明确的发现：如果代码层面对缓存数据的大小的预估不足，将会发生很严重的内存浪费/碎片。

例如：设计了大量 Size 为 4bytes 的缓存，这些缓存会被存到 Slab1 中，如果 Slab1 的范围是 0 ～ 104 bytes，那么，就会造成接近 100 bytes 的浪费。

### 数据回收

Memcache 不会监视记录是否过期，而是在 get 时查看记录的时间戳，检查记录是否过期。因此 Memcache 不会在过期监视上耗费 CPU 时间。过期的记录不会被删除，而是变得透明，客户端无法看见该数据，并且其 Chunk 可以被重复利用，Memcache 会优先使用已过期的 Chunk。

Memcache 的 LRU 触发会在内存空间即将不足时触发（无法从 slab class 获取新的空间），这时候就从最近未被使用的记录中搜索并将其空间分配给新的记录，直到 OOM。